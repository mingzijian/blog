# 类加载机制

## 类加载器（ClassLoader）

### 类加载器种类

> https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3
> There are two kinds of class loaders: the bootstrap class loader supplied by the Java Virtual Machine, and user-defined class loaders.

站在 JVM 的角度来说

类加载器有两种：JVM 提供的**引导类加载器**和用户**自定义类加载器**

![image-20240325113723399](https://gitee.com/mingzijian/resources/raw/master/picgo/2024-03/image-20240325113723399.png)

## 类加载方式



### 显示加载

直接调用`class.forName(…)`来把所需的类加载到 JVM

### 隐式加载

使用 `new` 等方式创建对象时，会隐式地调用类的加载器把对应的类加载到 JVM

### java 类的生命周期

![类加载](https://gitee.com/mingzijian/resources/raw/master/picgo/2024-03/24506a0020724d209362cde9feea9103.png)



## 双亲委派

### 什么是双亲委派

**父加载器优先加载**

当一个类加载器收到类加载请求后，优先将这个请求**（递归）委派**给父加载器去加载（循环至顶 BootStrapClassLoader），父加载器加载不了再由子加载器尝试加载。

### 为什么需要双亲委派（优点）

- **避免重复**：确保了同一个类在JVM中只有一个实例，避免了内存的浪费和类版本不一致的问题。
- **安全隔离**：Java核心库的类由顶层的引导类加载器加载，保证了核心库的稳定性和安全性。如果用户自定义的类与核心库中的类重名，也不会覆盖核心库的类。
- **维护有序**：类加载器的层次结构使得类加载过程有序进行，有助于维护和管理类版本。

### 打破双亲委派

需要打破双亲委派的场景：

1. **隔离类**：当你希望加载的类与系统类库或其他应用程序类库隔离时，以避免版本冲突。
2. **热部署**：在应用程序运行期间动态加载和卸载类，例如在Web应用程序或OSGi框架中。
3. **核心库修改**：当你需要修改或替换Java核心库中的类时。
4. **加密类**：对类进行加密，然后在运行时解密和加载。
5. **多版本共存**：当需要在同一个JVM中使用同一个类库的不同版本时。

如何打破双亲委派：

要打破双亲委派模型，你需要自定义类加载器，并重写`loadClass`方法，而不是`findClass`方法。`loadClass`方法是双亲委派模型的入口点，它会首先尝试使用父类加载器加载类，如果父类加载器无法完成加载，才会调用`findClass`方法。



https://zhuanlan.zhihu.com/p/623013988
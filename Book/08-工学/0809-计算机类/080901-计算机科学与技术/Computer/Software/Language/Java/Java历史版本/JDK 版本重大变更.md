



## JDK 25（LTS）
- 模式匹配通过允许在所有模式上下文中使用基本类型而得到增强。` instanceof ` 运算符和 ` switch ` 表达式及语句得以扩展，从而能够处理所有基本类型。（第三次预览）
- 模块导入声明使您能够简洁地导入模块导出的所有包。
- 紧凑的源文件和实例  main  方法使学生能够编写他们的第一个程序，而无需了解为大型程序设计的全部语言特性。
- 灵活的构造函数体允许在显式的构造函数调用（例如  super(..)  或  this(..) ）之前出现构造函数中的语句。


## JDK 24
- 模式匹配通过允许在所有模式上下文中使用基本类型而得到增强。` instanceof ` 运算符和 ` switch ` 表达式及语句已扩展为支持所有基本类型。
- 模块导入声明使您能够简洁地导入模块导出的所有包。
- 灵活的构造函数体允许在显式调用构造函数（例如  super(..)  或  this(..) ）之前在构造函数中出现语句。这些语句不能引用正在构造的实例，但可以初始化其字段。在调用另一个构造函数之前初始化字段会使类在方法被重写时更可靠。
- 简单的源文件和实例主方法使初学者能够编写他们的第一个程序，而无需了解为大型程序设计的语言特性。
- 在 64 位架构的 HotSpot JVM 中，对象头的大小从 96 位和 128 位缩减至 64 位。这将减少堆大小，提高部署密度，并增强数据局部性。
- G1 垃圾回收器屏障的实现得到了简化，这些屏障用于记录应用程序内存访问的信息，其扩展工作从 C2 JIT 编译管道的早期阶段移至了后期阶段。
- 提前类加载和链接通过在 HotSpot Java 虚拟机启动时使应用程序的所有类立即处于已加载和已链接的状态，从而缩短了启动时间。这是通过在应用程序的一次运行期间对其进行监控，并将所有类的已加载和已链接形式存储在缓存中以供后续运行使用来实现的。
- ZGC 垃圾回收器默认以分代模式运行。ZGC 的非分代模式已被移除。
- 通过在不固定的情况下同步虚拟线程，可以提高使用  synchronized  方法和语句的 Java 代码的可扩展性，其方式是安排在这些结构中阻塞的虚拟线程释放其底层平台线程，以便其他虚拟线程使用。



## JDK 23
- 模式匹配现已得到增强，允许在所有模式上下文中使用基本类型模式。
- 模块导入声明使您能够通过模块导入声明简洁地导入模块导出的所有包。它简化了模块化库的复用，而无需导入的代码处于模块中。
- 灵活的构造函数体使您能够在显式调用构造函数之前添加不引用正在创建的实例的语句。此功能有助于您通过执行复杂的计算来准备要传递给超类构造函数的参数，或者验证要传递给超类构造函数的参数。
- 隐式声明的类和实例主方法使学生即使尚未掌握为大型程序设计的全部语言特性，也能编写他们的第一个程序。学生可以为单类程序编写精简的声明，然后随着技能的增长，无缝地扩展其程序以使用更高级的特性。
- 字符串模板功能撤回。 字符串模板在 JDK 21（JEP 430）和 JDK 22（JEP 459）中首次进行了预览。原计划在 JDK 23（JEP 465）中再次预览该功能。然而，在收到大量反馈和讨论之后，我们得出结论，该功能目前的形式并不合适。对于更好的设计方案尚无共识，因此我们暂时撤回了该功能，JDK 23 将不会包含它。
- ZGC 垃圾回收器现在默认以分代模式运行。ZGC 的非分代模式已被弃用，即将移除。这通常会提高应用程序的性能，不过少数本质上为非分代的工作负载可能会受到负面影响。
- Oracle GraalVM 的即时编译器（Graal JIT）现在作为实验性选项在 Oracle JDK 提供的即时编译器中可用。
- JavaDoc 文档注释现在可以使用 Markdown 语法以及 HTML 元素和 JavaDoc 标签来编写。



## JDK 22
- 当需要变量声明或嵌套模式但从未使用时，可以使用未命名变量和未命名模式。未命名模式可以出现在记录模式的模式列表中，并且可以替代类型模式。两者都用下划线字符  (_)  表示。
- 在构造函数中，您可以在显式调用构造函数之前添加不引用正在创建的实例的语句。您可以使用此功能通过执行复杂的计算来准备要传递给超类构造函数的参数，或者验证要传递给超类构造函数的参数。
- 字符串模板通过将文字与嵌入式表达式以及模板处理器相结合来生成专门的结果，从而补充了 Java 现有的字符串字面值和文本块。
- 预览功能中的“实例主方法”和“隐式声明类”使学生能够在无需掌握专为大型程序设计的全部语言特性的情况下编写他们的第一个程序。他们可以为单类程序编写精简的声明，然后随着技能的增长，无缝地扩展程序以使用更高级的特性。
- 外部函数与内存（FFM）API 使 Java 程序能够与 Java 运行时之外的代码和数据进行交互操作。此 API 使 Java 程序能够调用本地库并处理本地数据，而无需像使用 JNI 那样脆弱和危险。该 API 能够调用外部函数，即 JVM 之外的代码，并安全地访问外部内存，即不由 JVM 管理的内存。
- 流收集器使您能够创建自定义的中间操作，这使得流管道能够以现有内置中间操作难以实现的方式转换数据。
- 类文件 API 用于解析、生成和转换 Java 类文件。
- 结构化并发将不同线程中运行的多个任务视为一个工作单元，从而简化错误处理和取消操作，提高可靠性，并增强可观测性。
- 作用域值能够在线程内部以及跨线程之间共享不可变数据。
- 向量 API 被引入以表达向量计算，这些计算在运行时能够可靠地编译为受支持的 CPU 架构上的最优向量指令，从而实现优于等效标量计算的性能。
- 在 G1 中使用区域固定可降低延迟，从而在 Java 本地接口（JNI）关键区域无需禁用垃圾回收。
- Java 应用程序启动器得到了增强，能够运行以多个 Java 源代码文件形式提供的程序。这将有助于从小程序逐步过渡到大型程序。

## JDK 21（LTS）
- 记录模式和类型模式可以嵌套，从而实现一种强大、声明式且可组合的数据导航和处理形式。
- 一个 ` switch ` 语句会根据其选择器表达式的值将控制权转移到多个语句或表达式中的一个。将模式匹配扩展到 ` switch ` 可以让一个表达式与多个模式进行测试，每个模式都有特定的操作，从而能够简洁且安全地表达复杂的面向数据的查询。
- 字符串模板通过将文字与嵌入式表达式以及模板处理器相结合，来生成专门的结果，从而对 Java 现有的字符串字面量和文本块进行了补充。
- 未命名模式匹配记录组件而不声明组件的名称或类型。未命名变量是可以初始化但未使用的变量。都用下划线字符（_）表示。
- 未命名类和实例主方法使学生能够为单类程序编写简洁的声明，然后随着技能的提高，能够轻松地扩展程序以使用更高级的功能。
- 虚拟线程是轻量级线程，可减少编写、维护和调试高吞吐量并发应用程序的工作量。
- 通过 ZGC 扩展为维护年轻对象和年老对象的独立代，应用程序性能得到了提升。这将使 ZGC 能够更频繁地收集年轻对象，因为年轻对象往往生命周期较短。
- 当代理被动态加载到正在运行的 JVM 中时，会发出警告。

## JDK 20
- 虚拟线程是轻量级线程，可减少编写、维护和调试高吞吐量并发应用程序的工作量。这是一个预览 API。自上次发布以来，此 API 已进行了细微更改。
- 结构化并发将不同线程中运行的多个任务视为一个工作单元，从而简化错误处理和取消操作，提高可靠性，并增强可观测性。
- 作用域值能够在线程内部以及跨线程之间共享不可变数据。与线程局部变量相比，它们更受青睐，尤其是在使用大量虚拟线程时。
- 引入了一个 API 来表达向量计算，该 API 能够在运行时可靠地编译为支持的 CPU 架构上的最优向量指令，从而实现优于等效标量计算的性能。
- “表达式和语句的模式匹配”预览功能进一步完善。
- 预览 API 中的外部函数和内存 API 进一步完善。
- 有序集合是具有明确遍历顺序的集合。每个这样的集合都有一个明确的第一元素、第二元素，以此类推，直到最后一个元素。这是一个表示有序集合的接口，提供了统一的 API 来访问其第一个和最后一个元素，以及以逆序处理其元素。
- 密钥封装机制 API 用于密钥封装机制（KEM），这是一种使用公钥密码学来保护对称密钥的加密技术。

## JDK 19
- 虚拟线程是轻量级线程，可降低编写、维护和调试高吞吐量并发应用程序的工作量。
- 引入了一个 API 以简化结构化并发中的多线程编程。结构化并发将不同线程中运行的多个任务视为一个工作单元，从而简化错误处理和取消操作，提高可靠性并增强可观测性。
- 记录模式在此次发布中作为预览功能引入。
- 在本次发布中，对表达式和语句的模式匹配预览功能进行了重新预览。
- 外部函数和内存 API 使 Java 程序能够与 Java 运行时环境之外的代码和数据进行交互。
- 向量 API 被引入以表达向量计算，这些计算在运行时能够可靠地编译为支持的 CPU 架构上的最优向量指令，从而实现优于等效标量计算的性能。

## JDK 18
- 新的命令行工具  `jwebserver`  允许您启动一个仅提供静态文件服务的极简 Web 服务器。此工具对于原型设计和测试很有用。
- 在 JavaDoc 的标准文档生成工具（Doclet）中添加了一个  `@snippet`  标签，这简化了在 API 文档中包含示例源代码的过程。
- UTF-8 现已成为 Java SE API 的默认字符集。通过这一变更，依赖默认字符集的 API 在所有实现、操作系统、区域设置和配置中都将表现一致。
- 为主机名和地址解析定义了一个服务提供程序接口（SPI），以便  `java.net.InetAddress`  可以使用除平台内置解析器之外的解析器。
- 使用方法句柄的核心反射已重新实现。降低 ` java.lang.reflect`  和 ` java.lang.invoke`  API 的维护和开发成本。
- 在此次发布中，针对表达式和语句的模式匹配预览功能已重新预览。此功能允许将表达式与多个模式进行测试，每个模式都有特定的操作，从而能够简洁且安全地表达复杂的面向数据的查询。
- Java SE 17 引入的外部函数和内存 API 允许 Java 程序与 Java 运行时之外的代码和数据进行交互。此版本中该 API 重新进入孵化器阶段，并进行了增强。
- 向量 API 在 Java SE 16 中作为孵化 API 引入。在此版本中，该 API 重新孵化，并进行了增强和性能改进。

## JDK 17（LTS）
- 密封类在 Java SE 15 中首次预览，此次发布中已成为永久性特性。密封类和密封接口限制了哪些其他类或接口可以对其进行扩展或实现。
- 应用程序现在可以使用 JVM 范围内的过滤器工厂配置特定于上下文和动态选择的反序列化过滤器，该工厂会在每次单独的反序列化操作时被调用以选择一个过滤器。
- 提供了伪随机数生成器（PRNG）的新接口类型和实现，包括可跳跃的 PRNG 和额外的可拆分 PRNG 算法（LXM）类别。
- 在 macOS 上实现了新的 Java 2D 内部渲染管线，使用的是苹果的 Metal API。这是现有管线的替代方案，现有管线使用的是已弃用的苹果 OpenGL API。
- 默认情况下，JDK 的所有内部元素都受到严格的封装，除了关键的内部 API 如  `sun.misc.Unsafe` 。然而，将不再能够通过单个命令行选项来放宽内部元素的严格封装，就像在 JDK 9 至 JDK 16 中那样。
- 现在浮点运算始终严格遵循语义，不再同时存在严格的浮点语义（ strictfp ）和细微不同的默认浮点语义。
- 安全管理器及其相关 API 已被弃用，将在未来的版本中移除。
- 引入了对  switch  表达式和语句的模式匹配。此功能允许将表达式与多个模式进行测试，每个模式都有特定的操作，从而能够简洁且安全地表达复杂的面向数据的查询。
- “外部函数与内存 API”允许 Java 程序与 Java 运行时环境之外的代码和数据进行交互。
- 向量 API 在 Java SE 16 中作为孵化 API 引入。在此版本中，已纳入增强功能以及性能改进。

## JDK 16
- Java 编程语言为  `instanceof`
- 记录（Records）在 Java SE 14 中首次预览，此次发布中已成为永久性特性。此前的限制已放宽，内部类现在可以声明显式或隐式的静态成员，这包括隐式静态的记录类成员。  操作符添加了模式匹配功能。此功能使得程序中的常见逻辑，即从对象中条件性地提取组件，能够以更简洁和安全的方式表达。
- 默认情况下，JDK 的所有内部元素都受到严格的封装，但关键的内部 API（如  `sun.misc.Unsafe` ）除外。您可以选择自 JDK 9 起成为默认设置的宽松强封装。
- UNIX 域套接字通道已集成到 JDK 16 中。
- ZGC 会并发处理线程栈。 这使得 JVM 中的所有根节点都能在 ZGC 的并发阶段进行处理。
- 在 JDK 14 中孵化的 ` jpackage`  工具，如今已成为一个永久性的特性。该工具将 Java 应用程序打包成包含必要依赖项的特定平台的包。
- 弹性元空间对虚拟机内部的元空间和类空间实现进行了全面改革。未使用的 HotSpot 类元数据（即元空间）内存将返回给操作系统。这减少了元空间的占用，并简化了元空间代码，从而降低了维护成本。

## JDK 15
- 文本块在 Java SE 13 中首次预览，此次发布中已成为永久性功能，无需启用预览功能即可使用。
- Z 垃圾收集器（ZGC）已准备好投入生产环境使用，不再是实验性功能。通过使用命令行选项  `-XX:+UseZGC`  来启用 ZGC。
- 隐藏类是指其他类的字节码无法直接使用的类。隐藏类旨在供在运行时生成类并通过反射间接使用这些类的框架使用。

## JDK 14
- `switch` 语句得到了扩展，现在既可以作为语句使用，也可以作为表达式使用，这样两种形式都可以使用传统的  `case` ... :  标签（具有穿透功能）或新的  `case` ... ->  标签（不具有穿透功能），并且还新增了一个用于从 switch 表达式中返回值的语句。
- G1 已得到增强，以提升在非统一内存访问（NUMA）内存系统上的分配性能。
- JDK 飞行记录器数据现在可用作数据流，从而支持持续监控。
- 新增了特定于 JDK 的文件映射模式，以便  `FileChannel`  API 可用于创建指向非易失性（NVM）内存的  `MappedByteBuffer`  实例。
- 允许使用特定区域的会计格式来格式化货币，例如显示为（$3.27）而不是 -$3.27。
- 增强  `com.sun.management.OperatingSystemMXBean`  以确保其根据当前的操作环境（例如容器环境）报告值。用于获取操作系统信息的工具的 `MXBean` 已针对容器环境进行了改进。

## JDK 13
- 动态 CDS 归档扩展了应用程序类数据共享（ApsCDS），它允许 Java 应用程序退出时动态归档类。
- Java 语言中添加了文本块，这使得开发人员能够在需要时控制格式。预览功能。
- switch 表达式带返回值。预览功能。
- `java.net.Socket`  和 ` java.net.ServerSocket`  API 所使用的实现已被替换为一个更简单、更现代的实现，该实现易于维护和调试。
- 支持 Unicode 12.1。
- ZGC 得到了增强，能够将未使用的堆内存返回给操作系统，从而改善应用程序的内存占用情况。


## JDK 12

- JVM 常量 API 的引入，旨在对关键类文件和运行时构件的名义描述进行建模，尤其是可从常量池加载的常量。
- `switch` 语句扩展，使其既可以作为语句使用，也可以作为表达式使用。预览功能。
- 支持 Unicode 11.0。
- 2019 年 5 月开始的日本令和时代提供了方块字符支持。
- `NumberFormat` 新增了对以紧凑格式化数字的支持。


## JDK 11 （LTS）

- 甲骨文(Oracle)公司不再提供 JRE 和服务器版 JRE 的下载；因此，自动更新功能也不再可用。
- Java Web Start、Java 插件和 Java 控制面板在 JDK 中不可用。
- JavaFX 已不再包含在 JDK 中。可以从 https://openjfx.io/ 单独下载。
- JAXB 和 JAX-WS 已不再与 JDK 捆绑。